{
  "namespace": "contrail",
  "protocol": "ContrailProtocol",
  "doc": "Data structures for contrail",


  "types": [
	{"name": "SequenceReadByte",
	 "type": "record",
	 "doc": "Structure representing a DNA sequence read encoded as byte array.",
	 "fields":[
	 	{"name": "id", "type":"string", "doc":"ID for the read."},
	 	{"name": "dna", "type":"bytes","doc":"The dna sequence for this read."},
	 	{"name": "mate_pair_id", "type": "int", "doc": "ID indicating which mate pair this sequence belongs to"}
	 ]
	},
	{"name": "CompressedRead",
     "type": "record",
     "doc": "Structure representing a DNA sequence read. Each sequence is packed into an array of bytes using 3 bits per letter.",
     "fields":[
        {"name": "id", "type":"string", "doc": "ID for the read."},
        {"name": "dna", "type": "bytes", "doc": "The dna sequence for this read."},
        {"name": "length", "type": "int", "doc": "Length of the read."},
        {"name": "mate_pair_id", "type": "int", "doc": "ID indicating which mate pair this sequence belongs to"}
     ]
    },
   {"name": "CompressedSequence",
    "type": "record",
    "namespace": "contrail.sequences",
    "doc": "Structure representing a compressed DNA sequence read. Each sequence is packed into an array of bytes using 3 bits per letter.",
    "fields":[
       {"name": "dna", "type": "bytes", "doc": "The dna sequence for this read."},
       {"name": "length", "type": "int", "doc": "Length of the read."}
     ]
    },        
    {"name": "DNAStrand",
     "type":  "enum",
     "namespace": "contrail.sequences",
     "doc": "Enumeration for representing which DNAStrand a fragment comes from.",
     "symbols": ["FORWARD", "REVERSE"]
    },
    {"name": "ReadState",
     "type":  "enum",
     "symbols": ["END5", "END6", "END3", "MIDDLE", "I"]
    },               
    {"name": "R5Tag",
     "namespace": "contrail.graph",
     "type": "record",
     "doc": ["Stores information about how reads align to the sequence stored ",
             "in a node. Tag identifies the read a subsequence came from. ",
             "DNAStrand tells us which strand of this node corresponds to ",
             "the read."],
     "fields": [                  
                 {"name": "tag",
                  "type": "string"
                 },
                 {"name": "strand",
                  "type": "contrail.sequences.DNAStrand"
                 },
                 {"name": "offset",
                  "type": "int"
                 }  
               ]       
    },
    {"name": "GraphNodeKMerTag",
     "namespace": "contrail.graph",
     "type": "record",
     "doc": "Represent a tag assigned to nodes in the graph.",          
     "fields": [
            {"name": "read_tag", "type":"string",
             "doc": "Tag for the read we came from."
            },
            {"name": "chunk", "type":"int",
             "doc": "Identifies the position within the read where it came from."
            }
        ]
    },
    {"type": "enum",
     "name": "StrandsForEdge",
     "symbols": ["FF", "FR", "RF", "RR"],
     "namespace": "contrail.sequences"
    }, 
    {"name": "KMerEdge",
     "type": "record",
     "namespace": "contrail.graph",
     "doc": "Represent an edge between two KMers. Used only by BuildGraph.",
     "fields": [
        {"name": "strands", "type": "contrail.sequences.StrandsForEdge", 
         "doc": "Enum containing the strands for the edge",
         "order": "ignore"
        },
        {"name": "last_base", "type": "bytes", 
         "doc": "Represent the compressed base that we need to append to kmer to get the sequence in the terminating node for this edge.",
         "order": "ignore"
        },
        {"name": "tag", "type": "string",
         "doc": "string identifying the node.",
         "order": "ignore"
        },
        {"name": "chunk", "type": "int",
         "doc": "Integer identifying the chunk within the sequence the edge came from.",
         "order": "ignore"
        },
        {"name": "state", "type": "contrail.ReadState",
         "doc": "An enum identifying the state.",
         "order": "ignore"
        }          
     ]
    },
    {"type": "enum",
     "name": "EdgeDirection",
     "namespace": "contrail.graph",
     "symbols": ["INCOMING", "OUTGOING"]     
    },
    {"name": "EdgeData",
     "namespace": "contrail.graph",
     "type": "record",
     "doc": "Represent the data for a particular instance of an edge.",
     "fields": [ {"name": "strands",
                "type": "contrail.sequences.StrandsForEdge",
                "doc": "An enumeration indicating which strands are used in this edge."
               },
               {"name": "read_tags",
                "type": {"type": "array", "items": "string"},
                "doc": "Array of strings representing the reads this edge came from"
               }
             ]
    },
    {"name": "NeighborData",
     "type": "record",
     "namespace": "contrail.graph",
     "doc": "Represent the neighbor of some node.",
     "fields": [
                 {"name": "node_id",
                  "type": "string",
                  "doc": "The id for the destination node."
                 },
                 {"name": "edges", 
                  "type": {"type": "array", "items": "contrail.graph.EdgeData"},
                  "doc": "Describes the edges between these two nodes."
                 }
               ]
    },    
    {"name": "GraphNodeData",
     "namespace": "contrail.graph",
     "type": "record",
     "doc": "Represent a node in the DeBruijn Graph.",
     "fields": [ 
     			 // TODO(jlewi): Should we continue to store this field
     			 // after the QuickMerge stage or should we set it to null to
     			 // save space?
     		     {"name": "mertag", "type":"contrail.graph.GraphNodeKMerTag",
                  "doc": ["A tag for the node based on the read the sequence ",
                          "came from and the chunk within the read.",
                          "This field is primarily used by QuickMerge as a ",
                          "heuristic for guessing which nodes form chains."]
                 },
                 {"name": "node_id", 
                  "type": "string",
                  "doc": ["An id for this node. This must be consistent with ",
                          "the id used in neighbors to specify the terminal ",
                          "for an edge."]
                 },
                 {"name": "coverage", "type": "float",
                  "doc": ["Coverage is a float because when merging nodes it ",
                          "is set to a weighted average of the coverage of ",
                          "the nodes being merged."]
                 },
                 // TODO(jlewi): We should rename this canonical_source 
                 // because it won't always be length K.
                 {"name": "canonical_source_kmer", 
                  "type":"contrail.sequences.CompressedSequence", 
                  "doc": ["Sequence of bytes representing the compressed ", 
                          "canonical sequence corresponding to the source."]
                 },
                 {"name": "neighbors", 
                  "type": {"type": "array", 
                           "items":"contrail.graph.NeighborData"},
                  "doc": "An array of this node's neighbors."
                 },
                 {"name": "r5_tags", 
                  "type": {"type": "array", "items": "R5Tag",
                           "doc": ["The list of R5Tags keeps track of how the ",
                                   "reads align to this sequence."]
                          }
                 }
               ]
    },        
    {"name": "contrail.avro.CompressibleMessage", 
     "type": "record",
     "doc": ["Record for the messages outputted by the mapper in the ", 
             "Compressible stage."],
     "fields": [{"name": "from_node_id", 
                 "type": "string",
                 "doc":  "Id of the node the message is from."},
                {"name": "strands",
                 "type": "contrail.sequences.StrandsForEdge",
                 "doc": ["The strands for the edge. The edge is always an ",
                         "outgoing edge from from_node_id"]}]     
    },
    {"name": "contrail.avro.CompressibleMapOutput",
     "type": "record",
     "doc": ["Record used for the output of mapper stage in the compressible ",
             "phase."],
     "fields": [ {"name": "message", 
                  "type": ["null", "contrail.avro.CompressibleMessage"],
                  "doc": ["A message informing this node about which ",
                          "neighbors are part of linear chains."]
                 },
                 {"name": "node", "type": ["null", "contrail.graph.GraphNodeData"],
                  "doc": "The node the messages are sent to."
                 }                 
               ]
    },
    {"name": "contrail.avro.CompressibleStrands",
     "type": "enum",
     "symbols": ["NONE", "FORWARD", "REVERSE", "BOTH"]
    },
    // Using an enum to store which strands are compressible should
    // be slightly more space efficient then a list of strands.    
    {"name": "contrail.avro.CompressibleNodeData", 
     "type": "record",
     "doc": ["Record for the data outputted by the CompressibleStage. ", 
             "Each record contains a graph node and information about which ",
             "directions if any we can compress this node."],
     "fields": [{"name":"compressible_strands", 
                 "type": "contrail.avro.CompressibleStrands",
                 "doc":  ["Which strands of the node are compressible with ",
                          "respect to outgoing edges."]},
                {"name": "node",
                 "type": "contrail.graph.GraphNodeData",
                 "doc": "The node data."}]     
    }
	] // end types
}
