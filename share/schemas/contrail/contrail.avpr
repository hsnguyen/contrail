{
  "namespace": "contrail",
  "protocol": "ContrailProtocol",
  "doc": "Data structures for contrail",


  "types": [
	{"name": "SequenceReadByte",
	 "type": "record",
	 "doc": "Structure representing a DNA sequence read encoded as byte array.",
	 "fields":[
	 	{"name": "id", "type":"string", "doc":"ID for the read."},
	 	{"name": "dna", "type":"bytes","doc":"The dna sequence for this read."},
	 	{"name": "mate_pair_id", "type": "int", "doc": "ID indicating which mate pair this sequence belongs to"}
	 ]
	},
	{"name": "CompressedRead",
     "type": "record",
     "doc": "Structure representing a DNA sequence read. Each sequence is packed into an array of bytes using 3 bits per letter.",
     "fields":[
        {"name": "id", "type":"string", "doc": "ID for the read."},
        {"name": "dna", "type": "bytes", "doc": "The dna sequence for this read."},
        {"name": "length", "type": "int", "doc": "Length of the read."},
        {"name": "mate_pair_id", "type": "int", "doc": "ID indicating which mate pair this sequence belongs to"}
     ]
    },
   {"name": "CompressedSequence",
    "type": "record",
    "namespace": "contrail.sequences",
    "doc": "Structure representing a compressed DNA sequence read. Each sequence is packed into an array of bytes using 3 bits per letter.",
    "fields":[
       {"name": "dna", "type": "bytes", "doc": "The dna sequence for this read."},
       {"name": "length", "type": "int", "doc": "Length of the read."}
     ]
    },        
    {"name": "DNAStrand",
     "type":  "enum",
     "namespace": "contrail.sequences",
     "doc": "Enumeration for representing which DNAStrand a fragment comes from.",
     "symbols": ["FORWARD", "REVERSE"]
    },
    {"name": "ReadState",
     "type":  "enum",
     "symbols": ["END5", "END6", "END3", "MIDDLE", "I"]
    },               
    {"name": "R5Tag",
     "namespace": "contrail.graph",
     "type": "record",
     "doc": ["Stores information about how reads align to the sequence stored ",
             "in a node. Tag identifies the read a subsequence came from. ",
             "DNAStrand tells us which strand of this node corresponds to ",
             "the read."],
     "fields": [                  
                 {"name": "tag",
                  "type": "string"
                 },
                 {"name": "strand",
                  "type": "contrail.sequences.DNAStrand"
                 },
                 {"name": "offset",
                  "type": "int"
                 }  
               ]       
    },
    {"name": "GraphNodeKMerTag",
     "namespace": "contrail.graph",
     "type": "record",
     "doc": "Represent a tag assigned to nodes in the graph.",          
     "fields": [
            {"name": "read_tag", "type":"string",
             "doc": "Tag for the read we came from."
            },
            {"name": "chunk", "type":"int",
             "doc": "Identifies the position within the read where it came from."
            }
        ]
    },
    {"type": "enum",
     "name": "StrandsForEdge",
     "symbols": ["FF", "FR", "RF", "RR"],
     "namespace": "contrail.sequences"
    }, 
    {"name": "KMerEdge",
     "type": "record",
     "namespace": "contrail.graph",
     "doc": "Represent an edge between two KMers. Used only by BuildGraph.",
     "fields": [
        {"name": "strands", "type": "contrail.sequences.StrandsForEdge", 
         "doc": "Enum containing the strands for the edge",
         "order": "ignore"
        },
        {"name": "last_base", "type": "bytes", 
         "doc": "Represent the compressed base that we need to append to kmer to get the sequence in the terminating node for this edge.",
         "order": "ignore"
        },
        {"name": "tag", "type": "string",
         "doc": "string identifying the node.",
         "order": "ignore"
        },
        {"name": "chunk", "type": "int",
         "doc": "Integer identifying the chunk within the sequence the edge came from.",
         "order": "ignore"
        },
        {"name": "state", "type": "contrail.ReadState",
         "doc": "An enum identifying the state.",
         "order": "ignore"
        }          
     ]
    },
    {"name": "EdgeData",
     "namespace": "contrail.graph",
     "type": "record",
     "doc": "Represent the data for a particular instance of an edge.",
     "fields": [ {"name": "strands",
                "type": "contrail.sequences.StrandsForEdge",
                "doc": "An enumeration indicating which strands are used in this edge."
               },
               {"name": "read_tags",
                "type": {"type": "array", "items": "string"},
                "doc": "Array of strings representing the reads this edge came from"
               }
             ]
    },
    {"name": "NeighborData",
     "type": "record",
     "namespace": "contrail.graph",
     "doc": "Represent the neighbor of some node.",
     "fields": [
                 {"name": "node_id",
                  "type": "string",
                  "doc": "The id for the destination node."
                 },
                 {"name": "edges", 
                  "type": {"type": "array", "items": "contrail.graph.EdgeData"},
                  "doc": "Describes the edges between these two nodes."
                 }
               ]
    },    
    {"name": "GraphNodeData",
     "namespace": "contrail.graph",
     "type": "record",
     "doc": "Represent a node in the DeBruijn Graph.",
     "fields": [ 
     			 // TODO(jlewi): Should we continue to store this field
     			 // after the QuickMerge stage or should we set it to null to
     			 // save space?
     		     {"name": "mertag", "type":"contrail.graph.GraphNodeKMerTag",
                  "doc": ["A tag for the node based on the read the sequence ",
                          "came from and the chunk within the read.",
                          "This field is primarily used by QuickMerge as a ",
                          "heuristic for guessing which nodes form chains."]
                 },
                 {"name": "node_id", 
                  "type": "string",
                  "doc": ["An id for this node. This must be consistent with ",
                          "the id used in neighbors to specify the terminal ",
                          "for an edge."]
                 },
                 {"name": "coverage", "type": "float",
                  "doc": ["Coverage is a float because when merging nodes it ",
                          "is set to a weighted average of the coverage of ",
                          "the nodes being merged."]
                 },
                 // TODO(jlewi): We should rename this canonical_source 
                 // because it won't always be length K.
                 {"name": "canonical_source_kmer", 
                  "type":"contrail.sequences.CompressedSequence", 
                  "doc": ["Sequence of bytes representing the compressed ", 
                          "canonical sequence corresponding to the source."]
                 },
                 {"name": "neighbors", 
                  "type": {"type": "array", 
                           "items":"contrail.graph.NeighborData"},
                  "doc": "An array of this node's neighbors."
                 },
                 {"name": "r5_tags", 
                  "type": {"type": "array", "items": "R5Tag",
                           "doc": ["The list of R5Tags keeps track of how the ",
                                   "reads align to this sequence."]
                          }
                 }
               ]
    },    
    {"name": "RemoveTipMessage",
     "type": "record",
     "doc": "Message used in the remove tip stage.",
     "fields": [
                 // TODO(jlewi): We probably shouldn't store canonical_dest_kmer.
                 // Rather, we should identify the nodes using the node_id.
                 {"name": "canonical_dest_kmer", 
                  "type": ["null", "contrail.sequences.CompressedSequence"],
                  "doc": ["The canonical sequence for the destination KMer to ",
                          "remove the edge from."]
                 },
                 {"name": "edge_strands", 
                  "type": ["null", "contrail.sequences.StrandsForEdge"],
                  "doc": "The enumeration for the edge strands we want to delete."
                 },
                 {"name": "node", "type": ["null", "contrail.graph.GraphNodeData"],
                  "doc": "The node the messages are sent to."
                 }                 
               ]
    }
	] // end types
}
